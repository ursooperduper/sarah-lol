---
title: "Jan 28"
description: "No libraries, no canvas, only HTML elements."
day: 28
prompt: "No libraries, no canvas, only HTML elements."
date: "2026-01-28"
image: "/genuary-2026/28/thumb-28.png"
---

<style>
  :root{
    /* Poster size (locked) */
    --w: 540px;
    --h: 675px;

    /* Palette */
    --bg: #000000;
    --fg: #ffffff;
    --accent: #c8f230; /* neon yellow-green */

    /* Nervous system */
    --gap: 10px;
    --pad: 10px;
    --stroke: 2px;
    --radius: 8px;
    --tilt: 0deg;
    --jitter: 2px;
    --calm: 520ms;     /* transition duration */
    --density: 0.55;   /* 0..1 */
    --phase: 0;        /* 0..1 (breathing oscillator) */

    /* Mutation state */
    --mutate: 0;       /* 0 or 1 */
    --mut-jitter: 0px;
    --mut-stroke: 0px;
    --mut-gap: 0px;
  }



  .dot{
    width: 8px; height: 8px; border-radius: 99px;
    background: var(--accent);
    box-shadow: 0 0 10px color-mix(in oklab, var(--accent) 70%, transparent);
  }

  /* Poster frame */
  .frame{
    width: var(--w);
    height: var(--h);
    position: relative;
    background: var(--bg);
    overflow: hidden;
    border: 1px solid color-mix(in oklab, var(--fg) 22%, transparent);
    /* border-radius: 18px; */
    /* box-shadow: 0 18px 60px rgba(0,0,0,0.55); */
  }

  /* The living grid stays inside the poster */
  #poster{
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(14, 1fr);
    gap: calc(var(--gap) + var(--mut-gap));
    padding: var(--pad);
    box-sizing: border-box;

    transform: rotate(var(--tilt));
    transform-origin: 50% 50%;
    transition:
      gap var(--calm) ease,
      padding var(--calm) ease,
      transform var(--calm) ease;
  }

  /* Modules */
  .cell{
    position: relative;
    border: calc(var(--stroke) + var(--mut-stroke)) solid color-mix(in oklab, var(--fg) 82%, transparent);
    border-radius: var(--radius);
    box-sizing: border-box;
    background: transparent;

    opacity: 0.08;
    transform: translate(0px,0px);
    transition:
      opacity var(--calm) ease,
      transform var(--calm) cubic-bezier(.2,.9,.2,1.1),
      border-width var(--calm) ease,
      border-color var(--calm) ease,
      border-radius var(--calm) ease;

    /* Keep it UI-ish */
    display: grid;
    place-items: center;
    user-select: none;
  }

  .cell::before{
    /* Subtle internal “UI” detail line */
    content: "";
    position: absolute;
    inset: 10px;
    border-radius: calc(var(--radius) * 0.75);
    border: 1px solid color-mix(in oklab, var(--fg) 18%, transparent);
    opacity: 0;
    transition: opacity var(--calm) ease;
    pointer-events: none;
  }

  .cell.active{
    opacity: 1;
    border-color: color-mix(in oklab, var(--fg) 90%, transparent);
  }
  .cell.active::before{
    opacity: 0.55;
  }

  .cell.accent{
    border-color: var(--accent);
    box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent) 45%, transparent);
  }

  /* Kinds (pure DOM shapes) */
  .cell[data-kind="chip"]{
    border-radius: 999px;
  }
  .cell[data-kind="rule"]{
    border-radius: 999px;
    border-width: 0;
    background: color-mix(in oklab, var(--fg) 70%, transparent);
    opacity: 0.12;
  }
  .cell[data-kind="dot"]{
    border-radius: 999px;
  }
  .cell[data-kind="dot"]::after{
    content: "";
    width: 10px; height: 10px;
    border-radius: 999px;
    background: color-mix(in oklab, var(--fg) 82%, transparent);
    box-shadow: 0 0 0 2px color-mix(in oklab, var(--fg) 15%, transparent);
  }
  .cell.accent[data-kind="dot"]::after{
    background: var(--accent);
    box-shadow: 0 0 12px color-mix(in oklab, var(--accent) 55%, transparent);
  }

  /* Minimal text labels (optional) */
  .label{
    position: absolute;
    left: 14px;
    bottom: 12px;
    font-size: 11px;
    opacity: 0.65;
    display: flex;
    gap: 10px;
    align-items: center;
    letter-spacing: 0.8px;
    text-transform: uppercase;
    pointer-events: none;
  }
  .label .tag{
    border: 1px solid color-mix(in oklab, var(--fg) 22%, transparent);
    border-radius: 999px;
    padding: 6px 8px;
  }

  /* “Startle” overlay blink (very subtle) */
  .flash{
    position: absolute;
    inset: 0;
    background: var(--accent);
    opacity: 0;
    mix-blend-mode: screen;
    pointer-events: none;
    transition: opacity 180ms ease;
  }
  .flash.on{ opacity: 0.10; }

  /* Helpful note for screenshots: scale 2x cleanly */
  .scale2x{
    transform: scale(2);
    transform-origin: top left;
  }

  @media (max-width: 700px){
    .frame{ transform: scale(0.85); transform-origin: top; }
  }
</style>


<div class="frame" id="frame">
  <div id="poster" aria-label="Living UI poster"></div>
  <div class="flash" id="flash"></div>
  <!-- <div class="label">
    <span class="tag">NO CANVAS</span>
    <span class="tag">HTML ONLY</span>
    <span class="tag">LIVING UI</span>
  </div> -->
</div>

# Notes
- Press R to re-roll
- Pres P to pause
- Press P to save a PNG

<script>
    // ============
    // Living UI engine (vanilla JS + CSS vars)
    // ============

    const poster = document.getElementById("poster");
    const frame = document.getElementById("frame");
    const flash = document.getElementById("flash");

    const COLS = 10, ROWS = 14;
    const CELL_COUNT = 120; // number of modules (not necessarily fills every grid unit)
    const kinds = ["card", "chip", "rule", "dot", "meter"];

    let paused = false;

    // Current + target (stubborn smoothing)
    const state = {
      gap: 10, gapT: 10,
      pad: 10, padT: 10,
      stroke: 2, strokeT: 2,
      radius: 14, radiusT: 14,
      tilt: 0, tiltT: 0,
      jitter: 2, jitterT: 2,
      calm: 520, calmT: 520,
      density: 0.55, densityT: 0.55,
      phase: 0,
      mutate: 0,
      mutJitter: 0, mutStroke: 0, mutGap: 0
    };

    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
    const lerp  = (a,b,t) => a + (b-a)*t;

    function setVar(name, value) {
      document.documentElement.style.setProperty(name, value);
    }

    function applyVars() {
      setVar("--gap", `${state.gap.toFixed(2)}px`);
      setVar("--pad", `${state.pad.toFixed(2)}px`);
      setVar("--stroke", `${state.stroke.toFixed(2)}px`);
      setVar("--radius", `${state.radius.toFixed(2)}px`);
      setVar("--tilt", `${state.tilt.toFixed(2)}deg`);
      setVar("--jitter", `${state.jitter.toFixed(2)}px`);
      setVar("--calm", `${Math.round(state.calm)}ms`);
      setVar("--density", `${state.density.toFixed(3)}`);

      setVar("--mutate", `${state.mutate}`);
      setVar("--mut-jitter", `${state.mutJitter.toFixed(2)}px`);
      setVar("--mut-stroke", `${state.mutStroke.toFixed(2)}px`);
      setVar("--mut-gap", `${state.mutGap.toFixed(2)}px`);
    }

    // Build modules once; we only change classes + inline transforms
    const cells = [];

    function randInt(min, max) { return Math.floor(min + Math.random()*(max-min+1)); }
    function pick(arr) { return arr[(Math.random()*arr.length)|0]; }

    function buildPoster() {
      poster.innerHTML = "";
      cells.length = 0;

      for (let i = 0; i < CELL_COUNT; i++) {
        const d = document.createElement("div");
        d.className = "cell";
        d.dataset.kind = pick(kinds);

        // Grid spans (keep it tasteful)
        const cSpan = (Math.random() < 0.70) ? 1 : (Math.random() < 0.85 ? 2 : 3);
        const rSpan = (Math.random() < 0.72) ? 1 : (Math.random() < 0.90 ? 2 : 3);

        d.style.gridColumn = `span ${cSpan}`;
        d.style.gridRow = `span ${rSpan}`;

        // Optional micro UI detail (tiny bars) for "meter"
        if (d.dataset.kind === "meter") {
          d.style.placeItems = "stretch";
          d.style.padding = "8px";
          d.innerHTML = `<div style="
            width:100%; height:100%;
            border-radius: 999px;
            border: 1px solid color-mix(in oklab, var(--fg) 22%, transparent);
            position:relative;
            overflow:hidden;">
              <div class="fill" style="
                position:absolute; left:0; top:0; bottom:0;
                width:${randInt(18,88)}%;
                background: color-mix(in oklab, var(--fg) 72%, transparent);
                opacity:0.35;"></div>
          </div>`;
        }

        poster.appendChild(d);
        cells.push(d);
      }
    }

    // Layout "curiosity": reroll spans occasionally (but not every tick)
    function rerollLayout() {
      for (const d of cells) {
        const cSpan = (Math.random() < 0.70) ? 1 : (Math.random() < 0.85 ? 2 : 3);
        const rSpan = (Math.random() < 0.72) ? 1 : (Math.random() < 0.90 ? 2 : 3);
        d.style.gridColumn = `span ${cSpan}`;
        d.style.gridRow = `span ${rSpan}`;
        // reset transforms so it doesn't drift forever
        d.style.transform = `translate(0px, 0px)`;
      }
    }

    // Pick new targets (curious)
    function pickTargets() {
      state.gapT = clamp(randInt(2, 22), 2, 22);
      state.padT = clamp(randInt(6, 22), 6, 22);
      state.strokeT = clamp(1 + Math.random()*3.5, 1, 4.5);
      state.radiusT = clamp(randInt(6, 28), 4, 30);
      // mostly upright; occasionally tilt
      state.tiltT = (Math.random() < 0.78) ? 0 : (Math.random() < 0.5 ? -6 : 6);
      state.jitterT = clamp(Math.random()*10, 0, 10);
      state.densityT = clamp(Math.random(), 0.12, 0.95);
      state.calmT = clamp(randInt(220, 1200), 180, 1400);
    }

    // Activate subset (density), sprinkle accent states
    function updateCells() {
      const activeCount = Math.floor(cells.length * state.density);

      // shuffle indices (fast)
      const indices = Array.from({length: cells.length}, (_, i) => i);
      for (let i = indices.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      const activeSet = new Set(indices.slice(0, activeCount));

      // accent: a few of the active ones
      const accentCount = Math.max(2, Math.floor(activeCount * 0.08));
      const accentSet = new Set(indices.slice(0, accentCount));

      const baseJ = state.jitter + state.mutJitter;

      cells.forEach((cell, idx) => {
        const isActive = activeSet.has(idx);
        cell.classList.toggle("active", isActive);
        cell.classList.toggle("accent", isActive && accentSet.has(idx));

        // jitter = living UI fidget
        const dx = (Math.random() * 2 - 1) * baseJ;
        const dy = (Math.random() * 2 - 1) * baseJ;
        cell.style.transform = `translate(${dx.toFixed(2)}px, ${dy.toFixed(2)}px)`;

        // optional: meters flicker slightly
        const fill = cell.querySelector?.(".fill");
        if (fill && isActive && Math.random() < 0.35) {
          fill.style.width = `${randInt(10, 92)}%`;
          fill.style.background = cell.classList.contains("accent")
            ? "color-mix(in oklab, var(--accent) 75%, transparent)"
            : "color-mix(in oklab, var(--fg) 72%, transparent)";
        }
      });
    }

    // Mutation event: one brief “sickness” in the system
    let mutationTimeout = null;
    function triggerMutation() {
      if (mutationTimeout) return; // one at a time
      state.mutate = 1;

      // mutate one axis of the system
      const mode = pick(["jitter", "stroke", "gap"]);
      if (mode === "jitter") {
        state.mutJitter = randInt(6, 16);
        state.mutStroke = 0;
        state.mutGap = 0;
      } else if (mode === "stroke") {
        state.mutStroke = randInt(2, 5);
        state.mutJitter = 0;
        state.mutGap = 0;
      } else {
        state.mutGap = randInt(-6, 10);
        state.mutJitter = 0;
        state.mutStroke = 0;
      }

      // recover
      mutationTimeout = setTimeout(() => {
        state.mutate = 0;
        state.mutJitter = 0;
        state.mutStroke = 0;
        state.mutGap = 0;
        mutationTimeout = null;
      }, randInt(900, 1600));
    }

    // Startle: brief accent flash + spike jitter targets
    function startle() {
      flash.classList.add("on");
      setTimeout(() => flash.classList.remove("on"), 140);

      // quick spike
      state.jitterT = clamp(state.jitterT + randInt(4, 10), 0, 18);
      state.gapT = clamp(state.gapT + randInt(-3, 6), 2, 26);
      // then settle
      setTimeout(() => pickTargets(), 250);
    }

    // Main tick: stubborn smoothing + occasional curiosity
    let lastLayoutReroll = 0;
    function tick(now) {
      if (paused) return;

      // Breathing phase (0..1)
      state.phase = (state.phase + 0.018) % 1;

      // Gentle breathing affects gap/pad slightly (but still bounded)
      const breath = Math.sin(state.phase * Math.PI * 2) * 0.5 + 0.5; // 0..1
      const breathBias = (breath - 0.5) * 2; // -1..1
      const breathGap = state.gapT + breathBias * 1.5;
      const breathPad = state.padT + breathBias * 1.0;

      // Stubborn smoothing coefficient
      const k = 0.07;

      state.gap    = lerp(state.gap, breathGap, k);
      state.pad    = lerp(state.pad, breathPad, k);
      state.stroke = lerp(state.stroke, state.strokeT, k);
      state.radius = lerp(state.radius, state.radiusT, k);
      state.tilt   = lerp(state.tilt, state.tiltT, k);
      state.jitter = lerp(state.jitter, state.jitterT, k);
      state.calm   = lerp(state.calm, state.calmT, k);
      state.density= lerp(state.density, state.densityT, k);

      // Curious events
      if (Math.random() < 0.08) pickTargets();         // new targets sometimes
      if (Math.random() < 0.06) triggerMutation();     // rare mutation

      // Very occasional layout reroll (keeps it feeling alive but not noisy)
      if (!lastLayoutReroll || now - lastLayoutReroll > 5200) {
        if (Math.random() < 0.25) {
          rerollLayout();
          lastLayoutReroll = now;
        }
      }

      applyVars();
      updateCells();
    }

    // Save PNG function - direct canvas rendering
    function savePNG() {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const scale = 2;
      const w = 540 * scale;
      const h = 675 * scale;
      
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      
      // Fill background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, w, h);
      
      // Draw each cell
      cells.forEach(cell => {
        const rect = cell.getBoundingClientRect();
        const frameRect = frame.getBoundingClientRect();
        
        // Scale coordinates to canvas
        const x = (rect.left - frameRect.left) * scale;
        const y = (rect.top - frameRect.top) * scale;
        const cellW = rect.width * scale;
        const cellH = rect.height * scale;
        
        // Get computed opacity and style
        const computedStyle = window.getComputedStyle(cell);
        const opacity = parseFloat(computedStyle.opacity);
        const borderRadius = parseFloat(computedStyle.borderRadius);
        const borderWidth = parseFloat(computedStyle.borderWidth);
        
        ctx.globalAlpha = opacity;
        
        // Draw border
        if (borderWidth > 0) {
          const isAccent = cell.classList.contains('accent');
          ctx.strokeStyle = isAccent ? '#c8f230' : 'rgba(255,255,255,0.5)';
          ctx.lineWidth = borderWidth * scale;
          ctx.beginPath();
          ctx.roundRect(x, y, cellW, cellH, borderRadius * scale);
          ctx.stroke();
        }
        
        // Draw dot center if applicable
        if (cell.dataset.kind === 'dot' && cell.classList.contains('active')) {
          const isAccent = cell.classList.contains('accent');
          ctx.fillStyle = isAccent ? '#c8f230' : 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.arc(x + cellW / 2, y + cellH / 2, 5 * scale, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      ctx.globalAlpha = 1.0;
      
      // Download
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `genuary-28-${timestamp}.png`;
        a.click();
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Keyboard controls
    window.addEventListener("keydown", (e) => {
      if (e.key === "r" || e.key === "R") {
        pickTargets();
        rerollLayout();
        updateCells();
      }
      if (e.key === "p" || e.key === "P") {
        paused = !paused;
        if (!paused) updateCells();
      }
      if (e.key === "s" || e.key === "S") {
        savePNG();
      }
      if (e.key === "m" || e.key === "M") {
        triggerMutation();
      }
      // 2x scale helper for clean IG screenshots (toggle)
      if (e.key === "2") {
        frame.classList.toggle("scale2x");
      }
    });

    frame.addEventListener("click", startle);

    // Init
    buildPoster();
    pickTargets();
    applyVars();
    updateCells();

    // Animate (requestAnimationFrame so it stays smooth)
    let last = performance.now();
    function loop(t){
      // throttle-ish: ~8–12 updates/sec keeps it “alive” without frantic flicker
      if (!paused && (t - last) > 110) {
        tick(t);
        last = t;
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>

[← Back to Genuary 2026](/creative-code/genuary-2026/)